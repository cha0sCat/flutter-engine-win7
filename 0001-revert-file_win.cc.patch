diff --git a/runtime/bin/BUILD.gn b/runtime/bin/BUILD.gn
index b3b71b39cdb..a85c713509e 100644
--- a/runtime/bin/BUILD.gn
+++ b/runtime/bin/BUILD.gn
@@ -64,7 +64,8 @@ template("build_libdart_builtin") {
       public_deps = [ "$fuchsia_sdk/pkg/fdio" ]
     }
     if (is_win) {
-      libs = [ "Pathcch.lib" ]
+      # PathCch is not available on Windows 7.
+      # libs = [ "Pathcch.lib" ]
     }
     include_dirs = [ ".." ]
     sources = builtin_impl_sources
diff --git a/runtime/bin/file_win.cc b/runtime/bin/file_win.cc
index 84349659449..9dda00e9a7a 100644
--- a/runtime/bin/file_win.cc
+++ b/runtime/bin/file_win.cc
@@ -13,7 +13,7 @@
 #include <Shlwapi.h>    // NOLINT
 #include <fcntl.h>      // NOLINT
 #include <io.h>         // NOLINT
-#include <pathcch.h>    // NOLINT
+// #include <pathcch.h>    // NOLINT
 #include <winioctl.h>   // NOLINT
 #undef StrDup           // defined in Shlwapi.h as StrDupW
 #include <stdio.h>      // NOLINT
@@ -386,21 +386,32 @@ static bool IsDeviceNamespacePrefixed(const std::unique_ptr<wchar_t[]>& path) {
 // not remove this limitation. Always check Win API documentation.
 std::unique_ptr<wchar_t[]> ToWinAPIPath(const char* utf8_path) {
   auto path = Utf8ToWideChar(utf8_path);
-  // Among other things ConvertToAbsolutePath replaces '/' with '\',
-  // which PathAllocCanonicalize won't do.
   auto abs_path = ConvertToAbsolutePath(path);
   if (abs_path.get() == nullptr) {
     return std::unique_ptr<wchar_t[]>(nullptr);
   }
 
-  PWSTR canonical_path;
-  if (PathAllocCanonicalize(abs_path.get(),
-                            PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH,
-                            &canonical_path) != S_OK) {
-    return std::unique_ptr<wchar_t[]>(nullptr);
+  if (IsDeviceNamespacePrefixed(abs_path) || IsLongPathPrefixed(abs_path)) {
+    return abs_path;
+  }
+
+  if (abs_path.get()[0] == L'\\' && abs_path.get()[1] == L'\\') {
+    // UNC path: convert `\\server\share\...` to `\\?\UNC\server\share\...`.
+    const wchar_t* kUncPrefix = L"\\\\?\\UNC\\";
+    const size_t prefix_len = wcslen(kUncPrefix);
+    const wchar_t* unc_path = abs_path.get() + 2;
+    const size_t unc_len = wcslen(unc_path);
+    auto result = std::make_unique<wchar_t[]>(prefix_len + unc_len + 1);
+    wcscpy_s(result.get(), prefix_len + unc_len + 1, kUncPrefix);
+    wcscat_s(result.get(), prefix_len + unc_len + 1, unc_path);
+    return result;
   }
-  auto result = std::unique_ptr<wchar_t[]>(wcsdup(canonical_path));
-  LocalFree(canonical_path);
+
+  const size_t abs_len = wcslen(abs_path.get());
+  auto result =
+      std::make_unique<wchar_t[]>(kLongPathPrefixLength + abs_len + 1);
+  wcscpy_s(result.get(), kLongPathPrefixLength + abs_len + 1, kLongPathPrefix);
+  wcscat_s(result.get(), kLongPathPrefixLength + abs_len + 1, abs_path.get());
   return result;
 }
 
@@ -593,25 +604,18 @@ bool File::CreateLink(Namespace* namespc,
     wcscpy_s(target_path.get(), target_path_max_length, name.get());
 
     // 2. target_path := remove_file(target_path)
-    HRESULT remove_result =
-        PathCchRemoveFileSpec(target_path.get(), target_path_max_length);
-    if (remove_result == S_FALSE) {
+    if (!PathRemoveFileSpecW(target_path.get())) {
       // If the file component could not be removed, then `name` is
       // top-level, like "C:\" or "/". Attempts to create files at those paths
       // will fail with ERROR_ACCESS_DENIED.
       SetLastError(ERROR_ACCESS_DENIED);
       return false;
-    } else if (remove_result != S_OK) {
-      SetLastError(remove_result);
-      return false;
     }
 
     // 3. target_path := combine(target_path, target)
-    HRESULT combine_result = PathCchCombineEx(
-        target_path.get(), target_path_max_length, target_path.get(),
-        target.get(), PATHCCH_ALLOW_LONG_PATHS);
-    if (combine_result != S_OK) {
-      SetLastError(combine_result);
+    if (PathCombineW(target_path.get(), target_path.get(), target.get()) ==
+        nullptr) {
+      SetLastError(ERROR_INVALID_NAME);
       return false;
     }
 
